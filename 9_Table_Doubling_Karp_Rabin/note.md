### Table Doubling
해시 테이블은 __setitem__ 메서드를 사용하여 구현되며, 키를 해싱하여 인덱스를 가져옵니다. 만약 해당 인덱스가 이미 사용 중이라면, 알고리즘은 선형 방식으로 다음 빈 슬롯을 탐색합니다. 만약 해시 테이블의 로드 팩터(해시 테이블의 용량 대비 아이템 수의 비율)가 0.7을 초과한다면, 해시 테이블의 용량을 두 배로 늘립니다.

__getitem__ 메서드를 사용하여 해시 테이블에서 아이템을 검색할 때는, 키를 해싱하여 인덱스를 가져옵니다. 해당 인덱스의 슬롯이 비어 있거나 다른 키를 가지고 있다면, 알고리즘은 선형 방식으로 다음 슬롯을 탐색합니다. 모든 슬롯을 탐색한 후에도 슬롯이 여전히 비어 있거나 다른 키를 가지고 있다면, KeyError를 발생시킵니다.

__delitem__ 메서드를 사용하여 해시 테이블에서 아이템을 삭제할 때는, 키를 해싱하여 인덱스를 가져옵니다. 해당 인덱스의 슬롯이 비어 있거나 다른 키를 가지고 있다면, 알고리즘은 선형 방식으로 다음 슬롯을 탐색합니다. 모든 슬롯을 탐색한 후에도 슬롯이 여전히 비어 있거나 다른 키를 가지고 있다면, KeyError를 발생시킵니다. 그렇지 않다면, 아이템은 해당 슬롯에서 삭제되고, 로드 팩터가 0.2 미만이라면 해시 테이블의 용량이 축소됩니다.

전반적으로 이 구현은 선형 탐색을 사용하는 오픈 어드레싱 방식으로 충돌을 해결합니다. 그러나 이 방식은 클러스터링이 발생할 수 있는데, 이는 긴 슬롯 체인이 형성되어 해시 테이블의 성능을 저하시킬 수 있습니다. 이 문제를 해결하기 위해 다른 방식, 예를 들어 separate chaining이나 double hashing을 사용할 수 있습니다.

### Θ?
컴퓨터 과학과 알고리즘 분석에서, 기호 "Θ" (theta로 발음)는 함수의 증가율의 점근적 상한과 하한을 나타내는 데 사용됩니다.
주어진 함수 f(n)에 대해, 어떤 최소값보다 큰 모든 n 값에 대해 c1g(n) <= f(n) <= c2g(n)인 두 개의 양의 상수 c1과 c2가 존재하면, f(n)은 Θ(g(n))의 순서를 갖는다고 말하고 f(n) = Θ(g(n))으로 쓴다.
더 간단하게 말하면, 이것은 f(n)의 증가율이 g(n)의 증가율과 일정한 상수 배수로 동일하다는 것을 의미합니다. 기호 Θ는 함수가 상수 배수 이상으로 빠르게 또는 느리게 성장하지 않는다는 의미로 타이트한 바운드를 나타내기 위해 사용됩니다.


### Θ(n + m) time = Θ(n) if m = Θ(n)
m = Θ(n)인 경우 Θ(n + m) 시간 = Θ(n)임을 증명하려면 m이 n과 같은 차수일 때 n + m과 n이 점근적으로 동등하다는 것을 보여야 합니다.
m = Θ(n)이라고 가정하면 어떤 양의 상수 c에 대해 m = cn이라고 쓸 수 있습니다. 따라서 n + m = n + cn = (c+1)*n입니다.
이제 우리는 n + m과 n이 상수 인자(c+1)만큼만 다르기 때문에 점근적으로 동일하다는 것을 알 수 있습니다. 따라서 다음과 같이 말할 수 있습니다.
n + m = Θ(n)은 m = Θ(n)일 때 n + m과 n이 같은 성장 속도(즉, 같은 자릿수)를 갖기 때문입니다.
마찬가지로 m = Θ(n)일 때 n과 n + m의 성장률이 같기 때문에 n = Θ(n + m)이라고 말할 수 있습니다.
따라서 m = Θ(n)인 경우 Θ(n + m) 시간 = Θ(n)입니다.

### When n reaches m
1 + 2 + ··· + n = n(n+1)/2 = n^2 + 1/2

1 + 2 + 4 + 8 + ··· + n =  2^0 + 2^1 + 2^2 + 2^3 + ··· + 2^k = 2^0(1 - 2^(k+1))/(1 - 2) = 2^0(1 - 2^(log₂n+1))/(1 - 2) = 2n - 1

y=2^(log₂n+1)
log₂y=log₂2^(log₂n+1)
log₂y=log₂n2log₂2
log₂y=log₂n
y=n

### Amortized cost
분할상환비용 (Amortized cost)는 연속된 일련의 작업에서의 평균 비용을 나타내는 개념으로, 단일 작업의 비용이 아닌 작업 순서 전체를 고려한 평균 비용을 의미합니다. 예를 들어, 배열 크기를 조정하거나 메모리를 재할당하는 작업을 포함하는 데이터 구조에서는, 단일 작업의 최악 케이스 비용 대신 분할상환비용을 사용하여 성능을 보다 정확하게 측정할 수 있습니다. 분할상환비용 개념을 사용하면 단일 작업의 성능뿐만 아니라 보다 긴 시간 동안 알고리즘 또는 데이터 구조의 성능을 이해할 수 있습니다
분할상환비용 = (작업 비용 총액) / (작업 수)

### Back to Hashing ?
만약 m = Θ(n)개의 버킷을 가지는 해시 테이블을 유지하고 간단한 균일 또는 유니버설 해싱을 사용한다면, 로드 팩터 α, 즉 각 버킷에 저장된 평균 항목 수는 Θ(1)입니다. 이것은 n개의 항목을 저장하기 위해 Θ(n)개의 버킷을 사용하기 때문입니다. 그러므로 버킷 당 평균 항목 수는 n/m = Θ(1)입니다.


### String Matching
grep -F 'word-to-search' file.txt

문자열 s가 문자열 t의 중요한 부분을 차지하는 상황에서는, O(|s|·(|t|−|s|))의 시간 복잡도가 제곱형태로 커질 가능성이 있으며, 최악의 경우 O(|s|·|t|)의 시간 복잡도를 가질 수 있습니다.

# Karp-Rabin Algorithm
해싱을 사용하여 패턴 문자열을 텍스트 문자열의 부분 문자열과 비교하는 문자열 매칭 알고리즘입니다.
이 알고리즘은 검색할 패턴의 해시값을 미리 계산한 후, 같은 크기의 윈도우를 이용하여 검색할 문자열을 슬라이딩하면서 각 윈도우의 해시값을 계산하고, 이를 패턴의 해시값과 비교합니다. 만약 해시값이 일치한다면, 알고리즘은 실제 문자열을 문자별로 비교하여 일치 여부를 확인합니다.이 알고리즘의 장점은 빠른 속도입니다. 해시값을 계산하는 부분은 미리 처리하기 때문에 검색을 수행할 때 일일이 비교하는 것보다 훨씬 빠르게 검색할 수 있습니다.


# Rolling Hash
롤링 해시는 문자열의 처음이나 끝에 단일 문자가 추가 또는 삭제될 때 문자열의 해시 값을 효율적으로 업데이트 할 수 있는 해시 함수입니다. 
롤링 해시를 위한 추상 데이터 유형(ADT)은 일반적으로 다음과 같은 메서드를 포함합니다
RollingHash 클래스는 __init__, append, skip, hash 메서드를 제공합니다.
__init__ 메서드는 주어진 문자열 s를 해시값으로 변환합니다. base와 mod는 각각 해시 함수의 기본값과 나머지 값을 나타냅니다.

append 메서드는 주어진 문자를 해시값에 추가합니다. 새 문자를 해시값에 추가할 때는 기존 해시값에 base를 곱한 후 새 문자의 아스키 코드 값을 더하고, mod로 나눈 나머지를 구합니다.

skip 메서드는 주어진 문자를 해시값에서 제거합니다. 삭제할 문자의 해시값을 구하고, power 값을 역수로 구한 후, 기존 해시값에서 삭제할 문자의 해시값을 뺀 후 mod로 나눈 나머지를 구합니다.
