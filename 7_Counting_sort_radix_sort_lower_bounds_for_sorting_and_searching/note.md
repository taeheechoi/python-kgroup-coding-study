### Linear time sorting
선형 시간 정렬 알고리즘(Linear time sorting algorithms)은 정렬할 원소의 개수 n에 대해 O(n)의 시간 복잡도를 가지는 정렬 알고리즘입니다. 이러한 알고리즘은 선형 정렬 알고리즘(Linear sorting algorithms)이라고도 불립니다.

가장 잘 알려진 선형 시간 정렬 알고리즘은 카운팅 정렬(Counting sort)입니다. 카운팅 정렬은 우선 입력 리스트에서 각각의 원소들이 몇 번 나왔는지를 세는 과정을 거칩니다. 그 다음, 이 정보를 바탕으로 각각의 원소들을 그들의 개수에 따라 출력 리스트에 추가하는 방식으로 정렬된 리스트를 만듭니다. 카운팅 정렬의 시간 복잡도는 입력 원소의 범위를 k라고 할 때, O(n + k)입니다. 입력 원소의 범위가 입력 크기에 비해 작을 경우, 카운팅 정렬은 매우 효율적일 수 있습니다.

또 다른 선형 시간 정렬 알고리즘은 버킷 정렬(Bucket sort)입니다. 버킷 정렬은 입력 리스트를 여러 개의 작은 버킷으로 분할한 후, 각각의 버킷을 다른 정렬 알고리즘을 사용하여 정렬합니다. 정렬된 버킷들은 이어붙여 최종적으로 정렬된 리스트를 만듭니다. 버킷 정렬의 평균 시간 복잡도는 O(n)이지만, 입력 데이터가 균등하게 분포하지 않은 경우 최악의 시간 복잡도는 O(n^2)가 될 수 있습니다.

이 외에도, 이미 언급된 것처럼, 레딕스 정렬(Radix sort)은 입력 원소의 자릿수 또는 문자열 길이 k에 대해 O(kn)의 시간 복잡도를 가집니다. 그러나 k가 상수이거나 n에 비해 작은 경우, 레딕스 정렬은 선형 시간 정렬 알고리즘으로 간주될 수 있습니다.

선형 시간 정렬 알고리즘은 입력 데이터의 범위가 작거나 큰 입력 크기에 유용합니다. 그러나 모든 종류의 입력 데이터에 대해 항상 효율적이거나 실용적이지 않을 수 있습니다.

### Radix sorting
레딕스 정렬(Radix sort)은 입력되는 수의 자릿수를 이용하여 정렬하는 알고리즘입니다. 레딕스 정렬은 입력 데이터를 가장 높은 자릿수부터 비교하여 정렬하는 방식을 취합니다.

레딕스 정렬의 동작 방식은 다음과 같습니다.

입력 데이터 중에서 가장 큰 자릿수를 찾습니다.
0부터 9까지의 모든 수에 대해, 해당 자릿수에 맞는 숫자들을 모아서 리스트를 만듭니다.
위에서 만든 리스트를 순서대로 이어붙입니다. 이 과정을 가장 작은 자릿수까지 반복합니다.
이 과정을 수행하면 최종적으로 정렬된 리스트를 얻을 수 있습니다. 레딕스 정렬의 시간 복잡도는 입력되는 수의 자릿수 k와 입력 데이터의 크기 n에 따라 O(kn)이 됩니다. 따라서, k가 작은 경우에는 레딕스 정렬이 매우 빠른 속도로 수행될 수 있습니다.

레딕스 정렬은 비교 정렬 알고리즘이 아니기 때문에 입력 데이터의 크기가 매우 클 경우에도 효과적으로 사용될 수 있습니다. 그러나, 레딕스 정렬은 공간 복잡도가 높다는 단점이 있습니다. 입력 데이터의 자릿수에 따라서 많은 메모리를 필요로 하기 때문입니다.

### 참조
- Explanation from chatGPT
- https://yjksw.github.io/low-upper-bound/
- https://www.cs.usfca.edu/~galles/visualization/RadixSort.html
- https://leetcode.com/problems/sort-an-array/
