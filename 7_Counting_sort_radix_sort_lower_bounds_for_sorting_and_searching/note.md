### Lower and Upper bound theory
Lower bound와 upper bound는 알고리즘 분석에서 사용되는 중요한 이론적 개념입니다.

Lower bound는 주어진 문제를 해결하기 위한 최소한의 계산 비용입니다. 예를 들어, n개의 원소가 있는 배열에서 최대 값을 찾는 문제를 해결하기 위한 비교 기반 알고리즘은 최소 n-1번의 비교가 필요합니다. 따라서 이 문제의 lower bound는 Ω(n)입니다.

Upper bound는 주어진 문제를 해결하는 데 필요한 최대 계산 비용입니다. 예를 들어, n개의 원소가 있는 배열에서 최대 값을 찾는 문제를 해결하기 위한 비교 기반 알고리즘은 최대 n-1번의 비교가 필요합니다. 따라서 이 문제의 upper bound는 O(n)입니다.

알고리즘의 효율성을 평가하려면 upper bound와 lower bound를 모두 고려해야 합니다. 만약 어떤 알고리즘의 시간 복잡도가 lower bound와 같다면 이 알고리즘은 최적 알고리즘이라고 할 수 있습니다.

이러한 lower bound와 upper bound 이론은 알고리즘 분석에서 매우 중요한 개념이며, 알고리즘을 설계하고 최적화하는 데 도움이 됩니다.

### Searching lower bound
lg n ± Θ(1)는 n의 로그값에 대한 가능한 범위를 나타내는 표현입니다. 여기서 Θ(1)은 상수 요소를 나타냅니다. 다시 말해, lg n ± Θ(1)은 실제 값으로부터 상수 요소 1 내외의 범위에서 lg n의 값을 가질 수 있음을 의미합니다.

예를 들어, lg n ± Θ(1) 시간 복잡도를 가진 알고리즘이 있다고 가정해 봅시다. 이 경우 알고리즘의 실제 실행 시간은 lg n 값보다 약간 높거나 낮을 수 있지만, 언제나 lg n에서 상수 요소 1 내외의 범위 내에 있을 것입니다. 즉, 만약 lg n의 실제 값이 10이라면, 알고리즘의 실행 시간은 9에서 11 사이의 어떤 값이 될 수 있습니다.

Θ(1) 표기법은 상수 요소를 나타내며, 따라서 lg n ± Θ(1) 시간 복잡도를 가진 알고리즘의 실행 시간은 입력 크기 n이 증가해도 크게 증가하지 않을 것입니다. 이는 n이 증가함에 따라 lg n 값이 매우 느리게 증가하기 때문이며, Θ(1)에서 나타낸 상수 요소는 전체 실행 시간에 미치는 영향이 매우 작기 때문입니다.

요약하면, "lg n ± Θ(1)"은 n의 로그값에 대한 가능한 범위를 나타내는 표현으로, 실제 값은 상수 요소 1 내외의 범위에서 변할 수 있으며, 알고리즘 분석에서 실행 시간을 설명하는 데 자주 사용됩니다.

### Linear time sorting
선형 시간 정렬 알고리즘(Linear time sorting algorithms)은 정렬할 원소의 개수 n에 대해 O(n)의 시간 복잡도를 가지는 정렬 알고리즘입니다. 이러한 알고리즘은 선형 정렬 알고리즘(Linear sorting algorithms)이라고도 불립니다.

가장 잘 알려진 선형 시간 정렬 알고리즘은 카운팅 정렬(Counting sort)입니다. 카운팅 정렬은 우선 입력 리스트에서 각각의 원소들이 몇 번 나왔는지를 세는 과정을 거칩니다. 그 다음, 이 정보를 바탕으로 각각의 원소들을 그들의 개수에 따라 출력 리스트에 추가하는 방식으로 정렬된 리스트를 만듭니다. 카운팅 정렬의 시간 복잡도는 입력 원소의 범위를 k라고 할 때, O(n + k)입니다. 입력 원소의 범위가 입력 크기에 비해 작을 경우, 카운팅 정렬은 매우 효율적일 수 있습니다.

또 다른 선형 시간 정렬 알고리즘은 버킷 정렬(Bucket sort)입니다. 버킷 정렬은 입력 리스트를 여러 개의 작은 버킷으로 분할한 후, 각각의 버킷을 다른 정렬 알고리즘을 사용하여 정렬합니다. 정렬된 버킷들은 이어붙여 최종적으로 정렬된 리스트를 만듭니다. 버킷 정렬의 평균 시간 복잡도는 O(n)이지만, 입력 데이터가 균등하게 분포하지 않은 경우 최악의 시간 복잡도는 O(n^2)가 될 수 있습니다.

이 외에도, 이미 언급된 것처럼, 레딕스 정렬(Radix sort)은 입력 원소의 자릿수 또는 문자열 길이 k에 대해 O(kn)의 시간 복잡도를 가집니다. 그러나 k가 상수이거나 n에 비해 작은 경우, 레딕스 정렬은 선형 시간 정렬 알고리즘으로 간주될 수 있습니다.

선형 시간 정렬 알고리즘은 입력 데이터의 범위가 작거나 큰 입력 크기에 유용합니다. 그러나 모든 종류의 입력 데이터에 대해 항상 효율적이거나 실용적이지 않을 수 있습니다.

### Radix sorting
레딕스 정렬(Radix sort)은 입력되는 수의 자릿수를 이용하여 정렬하는 알고리즘입니다. 레딕스 정렬은 입력 데이터를 가장 높은 자릿수부터 비교하여 정렬하는 방식을 취합니다.

레딕스 정렬의 동작 방식은 다음과 같습니다.

입력 데이터 중에서 가장 큰 자릿수를 찾습니다.
0부터 9까지의 모든 수에 대해, 해당 자릿수에 맞는 숫자들을 모아서 리스트를 만듭니다.
위에서 만든 리스트를 순서대로 이어붙입니다. 이 과정을 가장 작은 자릿수까지 반복합니다.
이 과정을 수행하면 최종적으로 정렬된 리스트를 얻을 수 있습니다. 레딕스 정렬의 시간 복잡도는 입력되는 수의 자릿수 k와 입력 데이터의 크기 n에 따라 O(kn)이 됩니다. 따라서, k가 작은 경우에는 레딕스 정렬이 매우 빠른 속도로 수행될 수 있습니다.

레딕스 정렬은 비교 정렬 알고리즘이 아니기 때문에 입력 데이터의 크기가 매우 클 경우에도 효과적으로 사용될 수 있습니다. 그러나, 레딕스 정렬은 공간 복잡도가 높다는 단점이 있습니다. 입력 데이터의 자릿수에 따라서 많은 메모리를 필요로 하기 때문입니다.

### 참조
- Explanation from chatGPT
- https://yjksw.github.io/low-upper-bound/
- https://www.cs.usfca.edu/~galles/visualization/RadixSort.html
- https://leetcode.com/problems/sort-an-array/
