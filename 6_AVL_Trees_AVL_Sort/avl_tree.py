# generated by ChatGPT
# In this implementation, AVLNode represents a node in the AVL tree, with data, left, right, and height properties. AVLTree represents the AVL tree itself, with methods to insert nodes, rotate nodes to balance the tree, get the height and balance factor of a node, and traverse the tree in pre-order.
class AVLNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None
        self.height = 1

class AVLTree:
    def insert(self, root, key):
        # Step 1 - Perform the normal BST insertion
        if not root:
            return AVLNode(key)
        elif key < root.data:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)
 
        # Step 2 - Update the height of the ancestor node
        root.height = 1 + max(self.get_height(root.left),
                              self.get_height(root.right))
 
        # Step 3 - Get the balance factor
        balance = self.get_balance(root)
 
        # Step 4 - If the node is unbalanced, then try out the 4 cases
        if balance > 1 and key < root.left.data:
            return self.right_rotate(root)
 
        if balance < -1 and key > root.right.data:
            return self.left_rotate(root)
 
        if balance > 1 and key > root.left.data:
            root.left = self.left_rotate(root.left)
            return self.right_rotate(root)
 
        if balance < -1 and key < root.right.data:
            root.right = self.right_rotate(root.right)
            return self.left_rotate(root)
 
        return root
 
    def left_rotate(self, z):
        y = z.right
        T2 = y.left
 
        y.left = z
        z.right = T2
 
        z.height = 1 + max(self.get_height(z.left),
                           self.get_height(z.right))
        y.height = 1 + max(self.get_height(y.left),
                           self.get_height(y.right))
 
        return y
 
    def right_rotate(self, z):
        y = z.left
        T3 = y.right
 
        y.right = z
        z.left = T3
 
        z.height = 1 + max(self.get_height(z.left),
                           self.get_height(z.right))
        y.height = 1 + max(self.get_height(y.left),
                           self.get_height(y.right))
 
        return y
 
    def get_height(self, root):
        if not root:
            return 0
        return root.height
 
    def get_balance(self, root):
        if not root:
            return 0
        return self.get_height(root.left) - self.get_height(root.right)
 
    def pre_order(self, root):
        if not root:
            return
 
        print("{0} ".format(root.data), end="")
        self.pre_order(root.left)
        self.pre_order(root.right)

# Example usage
my_tree = AVLTree()
root = None
root = my_tree.insert(root, 10)
root = my_tree.insert(root, 20)
root = my_tree.insert(root, 30)
root = my_tree.insert(root, 40)
root = my_tree.insert(root, 50)
root = my_tree.insert(root, 25)

print("Preorder traversal of the",
      "constructed AVL tree is")
my_tree.pre_order(root)
