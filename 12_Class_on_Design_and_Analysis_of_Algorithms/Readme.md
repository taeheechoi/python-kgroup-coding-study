탐욕 알고리즘의 특성을 이해하는 것은 그 알고리즘의 동작과 보장을 이해하는 데 중요합니다. 탐욕 알고리즘은 각 단계에서 지역적으로 최적의 선택을 하는 방식으로 전역적으로 최적의 해를 찾기를 바라는 방법입니다. 그러나 모든 문제에 대해 최적의 해를 보장하지는 않습니다.

다음은 탐욕 알고리즘의 특성을 이해하는 것이 필요한 몇 가지 이유입니다:

효율성: 탐욕 알고리즘은 보통 효율적이고 시간 복잡도가 낮은 알고리즘으로 설계됩니다. 특성을 이해함으로써 알고리즘의 실행 시간을 분석하고 특정 문제를 해결하기에 적합한지 판단할 수 있습니다.

근사해: 최적해를 찾는 것이 계산적으로 어려운 최적화 문제에서 탐욕 알고리즘은 근사해를 찾는 데 사용됩니다. 특성을 이해함으로써 탐욕 알고리즘이 제공하는 근사해의 품질을 평가할 수 있습니다.

정확성: 탐욕 알고리즘은 항상 최적의 해를 보장하지는 않지만, 실전에서 충분히 만족스러운 해를 제공하는 경우가 많습니다. 특성을 이해함으로써 언제 탐욕 알고리즘이 정확하고 만족스러운 해를 제공하는지 판단할 수 있습니다.

알고리즘 설계: 탐욕 알고리즘의 특성을 이해하면 새로운 알고리즘을 설계하거나 기존 알고리즘을 수정하는 데 도움이 됩니다. 성공적인 탐욕 알고리즘의 특성을 연구함으로써 통찰력을 얻고 유사한 문제를 효율적으로 해결하기 위한 새로운 전략을 개발할 수 있습니다.

트레이드오프: 탐욕 알고리즘은 전체적인 상황을 고려하지 않고 지역적으로 최적의 선택을 하는 방식입니다. 특성을 이해함으로써 탐욕적 접근법을 사용함으로써 최적성을 포기하고 효율성이나 간단함을 위한 트레이드오프에 대해 분석할 수 있습니다.

요약하면, 탐욕 알고리즘의 특성을 이해하는 것은 그들의 효율성, 근사해 보장, 정확성 및 트레이드오프 분석에 중요합니다. 다양한 문제를 해결하기 위해 탐욕 알고리즘을 효과적으로 사용하기 위해 언제 어떻게 사용해야 하는지 결정하는 데 도움이 됩니다.

프림 알고리즘(Prim's algorithm)은 최소 신장 트리(minimum spanning tree)를 찾기 위한 그리디 알고리즘입니다. 주어진 가중 그래프에서 모든 정점을 포함하면서 가장 작은 총 가중치를 갖는 연결 부분 그래프인 최소 신장 트리를 찾습니다.

프림 알고리즘의 동작은 다음과 같습니다:

임의의 정점을 시작 정점으로 선택합니다.
시작 정점과 연결된 간선 중에서 가장 작은 가중치를 가지는 간선을 선택하여 트리에 추가합니다.
이제 트리에 포함된 정점과 포함되지 않은 정점 사이의 간선 중에서 최소 가중치를 갖는 간선을 선택합니다.
선택된 간선을 트리에 추가하고, 해당 정점을 트리에 포함시킵니다.
모든 정점이 트리에 포함될 때까지 3단계와 4단계를 반복합니다.
프림 알고리즘은 우선순위 큐를 사용하여 다음에 추가할 간선을 효율적으로 선택합니다. 이를 통해 매 단계에서 최소 가중치 간선을 선택하고, 중복 선택되지 않도록 합니다. 알고리즘이 종료되면 최소 신장 트리가 완성됩니다.

프림 알고리즘은 주로 네트워크 설계, 클러스터링, 도로 계획 등의 문제에서 사용됩니다. 이 알고리즘은 시간 복잡도가 O(E log V)이며, 여기서 E는 간선의 수, V는 정점의 수입니다.

```python
import sys

def prim(graph):
    num_vertices = len(graph)
    # 트리에서 정점을 선택했는지 여부를 저장하는 배열
    visited = [False] * num_vertices
    # 최소 가중치 값을 저장하는 배열
    min_weights = [sys.maxsize] * num_vertices
    # 최소 신장 트리에서 해당 정점의 부모 정점을 저장하는 배열
    parents = [None] * num_vertices

    # 시작 정점을 0으로 설정
    min_weights[0] = 0
    parents[0] = -1

    for _ in range(num_vertices):
        # 방문하지 않은 정점 중에서 최소 가중치를 가지는 정점을 찾음
        min_weight = sys.maxsize
        min_index = -1
        for v in range(num_vertices):
            if not visited[v] and min_weights[v] < min_weight:
                min_weight = min_weights[v]
                min_index = v

        # 정점을 방문 처리
        visited[min_index] = True

        # 인접한 정점의 가중치를 업데이트
        for v in range(num_vertices):
            if (
                graph[min_index][v] != 0  # 인접한 정점이며
                and not visited[v]  # 방문하지 않은 정점이고
                and graph[min_index][v] < min_weights[v]  # 더 작은 가중치를 가진다면
            ):
                min_weights[v] = graph[min_index][v]
                parents[v] = min_index

    # 최소 신장 트리 출력
    print("Edge  Weight")
    for i in range(1, num_vertices):
        print(parents[i], "-", i, " ", graph[i][parents[i]])


# 가중 그래프를 인접 행렬로 표현
graph = [
    [0, 2, 0, 6, 0],
    [2, 0, 3, 8, 5],
    [0, 3, 0, 0, 7],
    [6, 8, 0, 0, 9],
    [0, 5, 7, 9, 0],
]

prim(graph)


```

### Reference

- https://youtu.be/-qMZNLoKre8?t=276

- https://www.youtube.com/watch?v=NG-GNfSaf9c&t=163s
