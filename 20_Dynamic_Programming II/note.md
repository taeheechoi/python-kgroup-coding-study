### 다이나믹 프로그래밍 단계

1. 문제 분할

- 주어진 문제를 부분 문제로 분할합니다.
- 부분 문제는 원래 문제보다 작고 해결하기 쉬운 문제여야 합니다.

2. 최적 부분 구조 찾기

- 부분 문제를 해결하는 방법을 찾습니다.
- 이때, 부분 문제의 해결 방법이 부분 문제의 최적 해결 방법이어야 합니다.

3. 부분 문제 해결 및 결과 저장

- 부분 문제를 해결하고 그 결과를 저장합니다.
- 이때, 중복 계산을 피하기 위해 결과를 저장해 둡니다.

4. 전체 문제 해결

- 저장된 결과를 이용하여 전체 문제를 해결합니다.
- 이때, 이전에 저장한 결과를 활용하여 중복 계산을 피합니다.

### Text Justification

```
words = ['Hello', 'world,', 'how', 'are', 'you', 'doing', 'today?']
L = 15

Hello world,
how are you
doing today?
```

위의 코드에서 compute_cost 함수는 i번째 단어부터 j번째 단어까지 한 줄에 나열했을 때, 해당 줄에 들어갈 문자열의 비용을 계산하는 함수입니다. 이때, 비용은 다음과 같이 계산됩니다.

- C = (L - len(단어들)) ^ 3, if j != n and L >= len(단어들), LaTex Rule, ^ 2 is ok
- C = 0, if j == n and L >= len(단어들)
- C = float('inf'), otherwise (j != n and L < len(단어들))

이 함수를 이용하여 부분 문제의 최적 해결 방법을 찾고, 전체 문제의 최적 해결 방법을 구하는 과정을 구현합니다. 마지막으로, 최소 비용을 출력합니다.

이것은 동적 프로그래밍을 사용하여 단어 감싸기 문제를 구현한 것입니다. 문제의 목표는 최대 너비 L의 한 줄에 주어진 단어 목록을 포맷하고 최소 비용으로 만드는 것입니다. 한 줄의 비용은 줄에 있는 빈 공간의 개수를 세제곱 한 것입니다.

이 구현은 하향식 동적 프로그래밍을 사용하여 각 하위 문제에 대한 최소 비용을 계산합니다. 하위 문제는 인덱스 i부터 목록 끝까지 단어를 포맷하는 데 필요한 최소 비용입니다. 원래 문제의 해결책은 인덱스 0부터 시작하는 하위 문제의 해결책입니다.

compute_cost 함수는 인덱스 i에서 j까지 한 줄을 포맷하는 데 필요한 비용을 계산합니다. 먼저 줄의 길이를 계산하여 줄에있는 각 단어의 길이를 합하고 그 사이의 공백 수를 추가합니다. 만약 줄이 단락의 마지막 줄이고 줄의 길이가 최대 너비보다 작거나 같으면 줄의 비용은 0입니다. 그렇지 않으면 줄의 길이가 최대 너비보다 크면 비용을 무한대로 설정하여 줄을 포맷할 수 없음을 나타냅니다. 마지막으로 줄의 길이가 최대 너비보다 작으면 최대 너비 L과 길이 length를 사용하여 비용을 계산합니다. 비용은 (L-length) \*\* 3 공식을 사용하여 계산됩니다.

word_wrap 함수는 n + 1 개의 항목으로 dp 동적 프로그래밍 테이블을 초기화합니다. 여기서 n은 단어 목록의 길이입니다. dp [i] 항목은 인덱스 i에서 목록 끝까지 단어를 포맷하는 데 필요한 최소 비용을 나타냅니다. 함수는 그런 다음 단어 목록의 인덱스를 n-1에서 0까지 반복하고 각 인덱스 i에서 j까지 시작하는 가능한 모든 줄을 포맷하는 데 필요한 비용을 계산합니다. 여기서 j는 i에서 n까지 범위입니다. 각 줄의 비용은 compute_cost 함수를 사용하여 계산되며 dp [j + 1]에 저장된 인덱스 j에서 시작하는 단어를 포맷하는 데 필요한 비용에 추가됩니다. 함수는 각 인덱스 i에서 시작하는 모든 가능한 줄의 최소 비용으로 dp [i]를 설정합니다. 마지막으로 함수는 전체 단어 목록을 포맷하는 데 필요한 최소 비용인 dp [0]을 반환합니다.

이 구현은 다른 구현과 비교하여 효율적입니다. 각 하위 문제의 최소 비용은 한 번만 계산되므로 같은 하위 문제가 두 번 계산되지 않습니다. 이를 통해 시간 복잡도가 개선됩니다.

그러나 이 구현은 여전히 최적의 솔루션을 찾는 것이 아니라 하위 문제의 최소 비용을 계산합니다. 때로는 최적의 솔루션이 아니더라도 더 가독성이 좋은 포맷이 있는 경우가 있습니다. 따라서 이 구현은 가장 작은 비용으로 단어를 포맷하는 것이 목표입니다.

이 구현의 시간 복잡도는 O (n ^ 2)입니다. 이는 각 단어가 다른 모든 단어와 비교되기 때문입니다. 이 구현을 최적화하려면 더 효율적인 알고리즘을 사용할 수 있습니다. 예를 들어, 동적 프로그래밍 대신 그리디 알고리즘을 사용하여 문제를 해결할 수 있습니다.
