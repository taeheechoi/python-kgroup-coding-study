### 다이나믹 프로그래밍 단계

1. 하위 문제를 정의한다 - 하위 문제의 개수를 센다

- 주어진 문제를 부분 문제로 분할합니다.
- 부분 문제는 원래 문제보다 작고 해결하기 쉬운 문제여야 합니다.

2. 해의 일부를 추측한다 - 선택지의 개수를 센다

- 부분 문제를 해결하는 방법을 찾습니다.
- 이때, 부분 문제의 해결 방법이 부분 문제의 최적 해결 방법이어야 합니다.

3. 하위 문제의 해를 연관짓는다 - 하위 문제당 시간을 계산한다 (선택?)

4. 재귀 + 메모이제이션 - 시간 = 하위 문제당 시간 \* 하위 문제의 개수
   또는 DP 테이블을 상향식으로 만든다 - 하위 문제가 비순환이고 위상 순서 확인 필요하다

- 부분 문제를 해결하고 그 결과를 저장합니다.
- 이때, 중복 계산을 피하기 위해 결과를 저장해 둡니다.

5. 기존 문제를 푼다 - 하위 문제와 같거나 하위 문제의 해를 합쳐서 푼다.

- 저장된 결과를 이용하여 전체 문제를 해결합니다.
- 이때, 이전에 저장한 결과를 활용하여 중복 계산을 피합니다.

### 글 정렬

```
words = ['Hello', 'world,', 'how', 'are', 'you', 'doing', 'today?']
L = 15

좋은 정렬
Hello world,
how are you
doing today?

나쁜 정렬
H e l l o
W o r l d,
H o w a r e
y o u
d o i n g
t o d a y ?
```

1. 하위 문제를 정의한다 - 하위 문제의 개수를 센다

- 접미사 단어[i:]의 나쁨을 최소화한다.
- 하위 문제 개수 = O(n:단어 개수)

2. 해의 일부를 추측한다 - 선택지의 개수를 센다

- 첫 줄을 어디서 끊을까 (i:j)

3. 하위 문제의 해를 연관짓는다 - 하위 문제당 시간을 계산한다 (선택?)

4. 재귀 + 메모이제이션 - 시간 = 하위 문제당 시간 \* 하위 문제의 개수
   또는 DP 테이블을 상향식으로 만든다 - 하위 문제가 비순환이고 위상 순서 확인 필요하다

- dp[i] = min(badness (i,j) + dp[j+1] for j in range (i, n))

5. 기존 문제를 푼다 - 하위 문제와 같거나 하위 문제의 해를 합쳐서 푼다.

- dp[0]

```python
def compute_cost(words, i, j, L): # 함수는 i번째 단어부터 j번째 단어까지 한 줄에 나열했을 때, 해당 줄에 들어갈 문자열의 비용을 계산하는 함수

    length = sum([len(word) for word in words[i:j+1]]) + j - i # 줄의 길이를 계산하여 줄에있는 각 단어의 길이를 합하고 그 사이의 공백 수를 추가

    if j == len(words) - 1 and length <= L: # 줄이 단락의 마지막 줄이고 줄의 길이가 최대 너비보다 작거나 같으면 줄의 비용은 0
        return 0
    elif length > L:  # 줄의 길이가 최대 너비보다 크면 비용을 무한대로 설정하
        return float('inf')
    else:
        return (L - length) ** 2 # 줄의 길이가 최대 너비보다 작으면 최대 너비 L과 길이 length를 사용하여 비용. LaTex Rule, ** 2 괜찮음?

def word_wrap(words, L):
    n = len(words)

    dp = [0] * (n + 1)  # n+1 크기의 리스트 dp를 생성합니다. dp[i]는 i번째 단어부터 마지막 단어까지  한 줄로 출력할 때 필요한 최소 비용

    for i in range(n-1, -1, -1): # 마지막 단어 부터 시작
        cost = [compute_cost(words, i, j, L) + dp[j+1] for j in range(i, n)]

        dp[i] = min(cost)

    return dp[0] # dp[0]은 첫번째 단어부터 마지막 단어까지 한 줄로 출력할 때 필요한 최소 비용
```

이 구현의 시간 복잡도는 O (n ^ 2)입니다. 이는 각 단어가 다른 모든 단어와 비교되기 때문입니다.

```python
assertword_wrap(['Hello', 'world,', 'how', 'are', 'you', 'doing', 'today?'], 15) == 25

# 123456789012345
# Hello world,___    --> 3*3 (3 공백 수)
# how are you____    ---> 4*4 (4 공백 수)
# doing today?___    ---> 0 (마지막 줄)

```
